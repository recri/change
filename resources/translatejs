#!/usr/bin/tclsh

# trim the data output to make us lean and fast
set ::omit {
    comment
    name image character hexagram pinyin constituting-ruler governing-ruler
    above above-interpretation below below-interpretation
}

# translate an xml format document into a json list
# taken from http://wiki.tcl.tk/3919 by Richard Suchenwirth

proc xml2list xml {
    regsub -all {>\s*<} [string trim $xml " \n\t<>"] "\} \{" xml
    set xml [string map {> "\} \{#text \{" < "\}\} \{"}  $xml]
	
    set res ""   ;# string to collect the result   
    set stack {} ;# track open tags
    set rest {}
    
    foreach item "{$xml}" {
	switch -regexp -- $item {
	    ^# {
		append res "{[lrange $item 0 end]} " ; #text item
	    }
	    ^/ {
		regexp {/(.+)} $item -> tagname ;# end tag
		set expected [lindex $stack end]
		if {$tagname!=$expected} {error "$item != $expected"}
		set stack [lrange $stack 0 end-1]
		append res "\}\} "
	    }
	    /$ { # singleton - start and end in one <> group
		regexp {([^ ]+)( (.+))?/$} $item -> tagname - rest
		set rest [lrange [string map {= " "} $rest] 0 end]
		append res "{$tagname [list $rest] {}} "
	    }
	    ^!-- { # comment
	    }
	    default {
		set tagname [lindex $item 0] ;# start tag
		set rest [lrange [string map {= " "} $item] 1 end]
		lappend stack $tagname
		append res "\{$tagname [list $rest] \{"
	    }
	}
	if {[llength $rest]%2} {error "att's not paired: $rest"}
    }
    if [llength $stack] {error "unresolved: $stack"}
    string map {"\} \}" "\}\}"} [lindex $res 0]
}
proc read-file {file} {
    set fp [open $file r]
    set data [read $fp]
    close $fp
    set data
}
set changes [xml2list [string trim [read-file changes.xml]]]
proc get-text {doc} {
    set text {}
    foreach item $doc {
	foreach {tag attrs body} $item {
	    switch -glob $tag {
		?text {
		    set lines $attrs
		    set lines [regsub -all "\n" $lines " "]
		    set lines [regsub -all "  +" $lines " "]
		    set lines [regsub -all \" $lines {\&quot;}]
		    append text " [string trim $lines]"
		    continue
		}
		br {
		    set text [string trim $text]\n
		    continue
		}
		* {
		    error "$tag in get-text"
		}
	    }
	}
    }
    return [string trim $text]
}
proc get-text-and-tags {doc tags} {
    set text {}
    array set content {}
    foreach item $doc {
	foreach {tag attrs body} $item {
	    switch -glob $tag {
		?text {
		    set lines $attrs
		    set lines [regsub -all "\n" $lines " "]
		    set lines [regsub -all "  +" $lines " "]
		    set lines [regsub -all \" $lines {\&quot;}]
		    append text " [string trim $lines]"
		    continue
		}
		br {
		    set text [string trim $text]\n
		    continue
		}
		* {
		    if {$tag in $tags} {
			set content($tag) [get-text $body]
			continue
		    }
		    error "$tag in get-text-and-tags $tags"
		}
	    }
	}
    }
    set result [list [string trim $text]]
    lappend result {*}[array get content]
    return $result
}

proc get-line {n gov con doc} {
    return [list line-$n {*}[get-text-and-tags $doc {comment}] governing-ruler $gov constituting-ruler $con]
}

proc traverse {indent doc} {
    foreach {tag attrs body} $doc { 
	switch $tag {
	    changes {
		set changes {}
		foreach item $body { lappend changes [traverse "  $indent" $item] }
		return $changes
	    }
	    change {
		set change {}
		foreach item $body { lappend change {*}[traverse "  $indent" $item] }
		return $change
	    }
	    number -
	    character -
	    comment -
	    lines -
	    hexagram -
	    pinyin {
		# there is a #text body with the hexagram number
		# there is a #text body with the character in utf-8
		# there is a #text body, this is the comment on the change
		# there is one #text in the body with the lines [6789]+
		# there is one #text in the body with the unicode hexagram in utf-8
		# there is one #text item with the pinyin transliteration
		return [list $tag [get-text $body]]
	    }
	    name -
	    above -
	    below {
		# there is a #text body with and optionally a comment and/or interpretation
		return [list $tag {*}[get-text-and-tags $body {comment interpretation}]]
	    }
	    image -
	    judgment {
		# there is a body with #text and br and possibly a comment
		return [list $tag [get-text-and-tags $body {comment}]]
	    }
	    line {
		# there is an n=? attribute,
		# optionally a governing_ruler=? attribute
		# optionally a constituting_ruler=? attribute
		# there is a body with #text and br and possibly a comment
		set myattrs(governing_ruler) false
		set myattrs(constituting_ruler) false
		array set myattrs $attrs
		return [get-line $myattrs(n) $myattrs(governing_ruler) $myattrs(constituting_ruler) $body]
	    }
	    default {
		error "$indent$tag $attrs"
		foreach item $body {
		    traverse "  $indent" $item
		}
	    }
	}
    }
}

proc keep-tag {tag} { return [expr {$tag ni $::omit}] }
proc keep-comments {} { return [keep-tag {comment}] }
proc is-comment {tag} { return [expr {[string first comment $tag] >= 0}] }

set nchanges [traverse {} $changes]
set index 0
set lmap {}
set bmap {}
set omap {}

proc toBits {lines} {
    set b 0
    foreach l [split $lines {}] {
	if {$l == 7} { set l 1 } elseif {$l == 8} { set l 0 } else { error "bad digit $l in $lines" }
	set b [expr {$b*2 + $l}]
    }
    return $b
}

puts "export class Changes {"
puts "static get changes() { return \["
foreach c $nchanges {
    # puts --------\n$c\n--------
    set pname {}
    set nname {}
    set lname {}
    puts "  {"
    foreach {name value} $c {
	switch -glob $name {
	    {interpretation} {
		if {$pname in {name above below}} {
		    # keep lookaside table of interpretations
		    if {[keep-tag $pname-$name]} {
			puts "    \"$pname-interpretation\" : \"$value\","
		    }
		} else {
		    error "unexpected predecessor of interpretation $pname"
		}
	    }
	    {judgment} - {image} {
		if {[keep-tag $name]} {
		    if {[llength $value] == 3 && [lindex $value 1] == "comment"} {
			set nname $name-comment
			set nvalue [lindex $value 2]
			set value [lindex $value 0]
			puts "    \"$name\" : \`$value\`,"
			if {[keep-comments]} {
			    puts "    \"$nname\" : \"$nvalue\","
			}
		    } else {
			puts "    \"$name\" : \`$value\`,"
		    }
		}
	    }
	    {line-?} {
		if {[keep-tag $name]} {
		    set lname $name
		    puts "    \"$name\" : \`$value\`,"
		}
	    }
	    {constituting-ruler} {
		if {[keep-tag $name]} {
		    if {$value eq "true"} {
			puts "    \"$lname-$name\" : \"$value\","
		    }
		}
	    }
	    {governing-ruler} {
		if {[keep-tag $name]} {
		    if {$value eq "true"} {
			puts "    \"$lname-$name\" : \"$value\","
		    }
		}
	    }
	    {comment} {
		if {[keep-comments]} {
		    if {$pname ni {interpretation {}}} {
			puts "    \"$pname-$name\" : \"$value\","
		    } else {
			puts "    \"$name\" : \"$value\","
		    }
		}
	    }
	    
	    {lines} {
		lappend lmap "\"$value\":\"$index\""
		set bits [toBits $value]
		lappend bmap "\"$bits\":\"$index\""
		set octs [format {%02o} $bits]
		lappend omap "\"$octs\":\"$index\""
		incr index 
	    }
	    * {
		if {[is-comment $name]} {
		    if {[keep-comments]} {
			puts "    \"$name\" : \"$value\","
		    }
		} else {
		    if {[keep-tag $name]} {
			puts "    \"$name\" : \"$value\","
		    }
		}
	    }
	}
	set pname $name
	set pvalue $value
    }
    puts "  },"
}
puts "]"
puts "}"
puts "static get lines() { return {[join $lmap ,]} }"
## puts "static get bits() { return {[join $bmap ,]} }"
## puts "static get octs() { return {[join $omap ,]} }"
## puts "static linesToBits(lines) { return parseInt(lines.split('').map(l => l === '7' ? '1' : '0').join(''), 2) }"
## puts "static bitsToLines(bits) { return bits.toString(2).split('').map(b => b === '1' ? '7' : '8').join('') }"
puts "}"
